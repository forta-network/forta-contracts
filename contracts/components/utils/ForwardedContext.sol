
pragma solidity ^0.8.4;

import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";

abstract contract ForwardedContext is ContextUpgradeable {

    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
    address private immutable _trustedForwarder;

    uint256 private constant ADDRESS_SIZE_BYTES = 20;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor(address trustedForwarder) {
        _trustedForwarder = trustedForwarder;
    }

    /// Checks if `forwarder` address provided is the trustedForwarder set in the constructor.
    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
        return forwarder == _trustedForwarder;
    }

    /**
     * @notice Gets sender of the transaction of signer if meta transaction.
     * @dev If the tx is sent by the trusted forwarded, we assume it is a meta transaction and 
     * the signer address is encoded in the last 20 bytes of msg.data.
     * @return sender address of sender of the transaction of signer if meta transaction.
     */
    function _msgSender() internal view virtual override returns (address sender) {
        if (isTrustedForwarder(msg.sender)) {
            return address(bytes20(msg.data[msg.data.length - ADDRESS_SIZE_BYTES: msg.data.length]));
        } else {
            return super._msgSender();
        }
    }

    /**
     * @notice Gets msg.data of the transaction or meta-tx.
     * @dev If the tx is sent by the trusted forwarded, we assume it is a meta transaction and 
     * msg.data must have the signer address (encoded in the last 20 bytes of msg.data) removed.
     * @return msg.data of the transaction of msg.data - signer address if meta transaction.
     */
    function _msgData() internal view virtual override returns (bytes calldata) {
        if (isTrustedForwarder(msg.sender)) {
            return msg.data[:msg.data.length - ADDRESS_SIZE_BYTES];
        } else {
            return super._msgData();
        }
    }
}
